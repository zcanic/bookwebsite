# Embedding Artificial Intelligence into ERP Software A Conceptual View on Business AI with Examples from SAP S4HANA (Siar Sarferaz) (z-library.sk, 1lib.sk, z-lib.sk) - ç¬¬104éƒ¨åˆ†

**åŸå§‹é¡µç **: 310 - 312
**æ®µè½æ•°é‡**: 8
**ç¿»è¯‘å·¥å…·**: Claude Code CLI

## ğŸ“– ç¿»è¯‘ç­–ç•¥å’Œä¸Šä¸‹æ–‡ä¿¡æ¯

- **ä½¿ç”¨çš„ç¿»è¯‘ç­–ç•¥**: å®Œæ•´ä¸Šä¸‹æ–‡
- **å‰æ–‡ä¸Šä¸‹æ–‡é¡µç **: 309-309 (414 å­—ç¬¦)
- **åæ–‡ä¸Šä¸‹æ–‡é¡µç **: 313-313 (1028 å­—ç¬¦)

*æ³¨ï¼šç¿»è¯‘æ—¶å·²ä½¿ç”¨"å®Œæ•´ä¸Šä¸‹æ–‡"ç­–ç•¥ï¼Œå‚è€ƒå‰åæ–‡ä¸Šä¸‹æ–‡ä»¥ç¡®ä¿æœ¯è¯­ä¸€è‡´æ€§å’Œå†…å®¹è¿è´¯æ€§*

**æœ¯è¯­è¯´æ˜**: 1. Side-by-Side (Extensibility): ç¿»è¯‘ä¸º'å¹¶è¡Œ'æˆ–ä¿ç•™'Side-by-Side'ï¼ŒæŒ‡åœ¨æ ¸å¿ƒERPç³»ç»Ÿæ—ä¾§è¿è¡Œæ‰©å±•åº”ç”¨çš„æ¨¡å¼ã€‚2. BAdI (Business Add-In): ä¸šåŠ¡åŠ è½½é¡¹ï¼ŒSAPçš„ä¸€ç§æ ‡å‡†å¢å¼ºæŠ€æœ¯ã€‚3. Consumption: ç¿»è¯‘ä¸º'æ¶ˆè´¹'ï¼ŒæŒ‡è°ƒç”¨æˆ–ä½¿ç”¨æœåŠ¡/æ¨¡å‹ã€‚4. ISLM: Intelligent Scenario Lifecycle Managementï¼Œæ™ºèƒ½åœºæ™¯ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚

---

Listing 20.2 Coding for Handling ISLM Metadata
METHOD IF_HEMI_MODEL_MANAGEMENT~GET_META_DATA.
    DATA LR_BADI TYPE REF TO CL_FQM_ML_DETECT2_BADI.
    TRY.
      GET BADI LR_BADI.
      CATCH CX_BADI_CONTEXT_ERROR.
      CATCH CX_BADI_NOT_IMPLEMENTED.
    ENDTRY.
    CALL BADI LR_BADI->GET_META_DATA
      IMPORTING
        ES_META_DATA = ES_META_DATA.
    ES_META_DATA-TRAINING_DATA_SET = 'I_CashFlowTrainingData'.
    ES_META_DATA-APPLY_DATA_SET    = 'I_RecmddLiquidityItem'.
    ES_META_DATA-
FIELD_DESCRIPTIONS = VALUE #( ( NAME = 'LiquidityItem' ROLE = 
CL_HEMI_CONSTANTS=>CS_FIELD_ROLE-TARGET )
    ( name = 'OriginSystem' role = CL_HEMI_CONSTANTS=>CS_FIELD_
ROLE-Â­key )
    ( name = 'OriginApplication' role = CL_HEMI_CONSTANTS=>CS_
FIELD_ROLE-Â­key )
    ( name = 'OriginDocument' role = CL_HEMI_CONSTANTS=>CS_FIELD_
ROLE-Â­key )
    ( name = 'OriginTransaction' role = CL_HEMI_CONSTANTS=>CS_
FIELD_ROLE-Â­key )
    ( name = 'OriginTransactionQualifier' role = CL_HEMI_
CONSTANTS=>CS_FIELD_ROLE-key )
    ( name = 'CashFlow' role = CL_HEMI_CONSTANTS=>CS_FIELD_
ROLE-Â­key )
    ).
  ENDMETHOD.

**ã€è¯‘æ–‡ã€‘** ä»£ç æ¸…å• 20.2 å¤„ç† ISLM å…ƒæ•°æ®çš„ä»£ç 
METHOD IF_HEMI_MODEL_MANAGEMENT~GET_META_DATA.
    DATA LR_BADI TYPE REF TO CL_FQM_ML_DETECT2_BADI.
    TRY.
      GET BADI LR_BADI.
      CATCH CX_BADI_CONTEXT_ERROR.
      CATCH CX_BADI_NOT_IMPLEMENTED.
    ENDTRY.
    CALL BADI LR_BADI->GET_META_DATA
      IMPORTING
        ES_META_DATA = ES_META_DATA.
    ES_META_DATA-TRAINING_DATA_SET = 'I_CashFlowTrainingData'.
    ES_META_DATA-APPLY_DATA_SET    = 'I_RecmddLiquidityItem'.
    ES_META_DATA-
FIELD_DESCRIPTIONS = VALUE #( ( NAME = 'LiquidityItem' ROLE = 
CL_HEMI_CONSTANTS=>CS_FIELD_ROLE-TARGET )
    ( name = 'OriginSystem' role = CL_HEMI_CONSTANTS=>CS_FIELD_
ROLE-Â­key )
    ( name = 'OriginApplication' role = CL_HEMI_CONSTANTS=>CS_
FIELD_ROLE-Â­key )
    ( name = 'OriginDocument' role = CL_HEMI_CONSTANTS=>CS_FIELD_
ROLE-Â­key )
    ( name = 'OriginTransaction' role = CL_HEMI_CONSTANTS=>CS_
FIELD_ROLE-Â­key )
    ( name = 'OriginTransactionQualifier' role = CL_HEMI_
CONSTANTS=>CS_FIELD_ROLE-key )
    ( name = 'CashFlow' role = CL_HEMI_CONSTANTS=>CS_FIELD_
ROLE-Â­key )
    ).
  ENDMETHOD.

---

Next, the method shown in Listing 20.3 is encapsulated as business add-in (BAdI) for extensibility. It implements the training logic in terms of reading the data based on the CDS view and calling the related PAL random decision tree algorithm.

**ã€è¯‘æ–‡ã€‘** æ¥ä¸‹æ¥ï¼Œä»£ç æ¸…å• 20.3 ä¸­å±•ç¤ºçš„æ–¹æ³•è¢«å°è£…ä¸ºä¸šåŠ¡åŠ è½½é¡¹ï¼ˆBAdIï¼‰ï¼Œä»¥å®ç°å¯æ‰©å±•æ€§ã€‚å®ƒå®ç°äº†è®­ç»ƒé€»è¾‘ï¼Œå³åŸºäº CDS è§†å›¾è¯»å–æ•°æ®ï¼Œå¹¶è°ƒç”¨ç›¸å…³çš„ PAL éšæœºå†³ç­–æ ‘ç®—æ³•ã€‚

---

Listing 20.3 Coding for Model Training
METHOD TRAINING
    BY DATABASE PROCEDURE FOR HDB LANGUAGE SQLSCRIPT OPTIONS 
SUPPRESS SYNTAX ERRORS READ-ONLY
    USING CL_FQM_ML_DETECT_BADI=>TRAINING.
    CALL "CL_FQM_ML_DETECT_BADI=>TRAINING"(
      it_data                => :it_data,
      it_param               => :it_param,
      et_model               => :et_model,
      et_variable_importance => :et_variable_importance,
      et_error_rate          => :et_error_rate,
      et_confusion_matrix    => :et_confusion_matrix
    );
  ENDMETHOD.
METHOD IF_FQM_ML_DETECT_BADI_INTF~TRAINING
     BY DATABASE PROCEDURE FOR HDB LANGUAGE SQLSCRIPT OPTIONS 
SUPPRESS SYNTAX ERRORS.
    lt_data = select CompanyCode, CertaintyLevel, Currency, 
PlanningLevel, CashPlanningGroup, GLAccount, BusinessPartner, 
Customer, Supplier, PartnerCompany, CostCenter, ProfitCenter,
    Segment, BusinessArea, Material, WBSElement, PaymentMethod, 
FinancialAccountType, FinancialTransactionType,  
BankAccountInternalID, LiquidityItem
    from :it_data;
   /* Call PAL random decision trees algorithm */
        CALL _sys_afl.pal_random_decision_trees(:lt_data, :it_
param, :et_model, :et_variable_importance, :et_error_rate, 
:et_confusion_matrix);
  ENDMETHOD.

**ã€è¯‘æ–‡ã€‘** ä»£ç æ¸…å• 20.3 æ¨¡å‹è®­ç»ƒä»£ç 
METHOD TRAINING
    BY DATABASE PROCEDURE FOR HDB LANGUAGE SQLSCRIPT OPTIONS 
SUPPRESS SYNTAX ERRORS READ-ONLY
    USING CL_FQM_ML_DETECT_BADI=>TRAINING.
    CALL "CL_FQM_ML_DETECT_BADI=>TRAINING"(
      it_data                => :it_data,
      it_param               => :it_param,
      et_model               => :et_model,
      et_variable_importance => :et_variable_importance,
      et_error_rate          => :et_error_rate,
      et_confusion_matrix    => :et_confusion_matrix
    );
  ENDMETHOD.
METHOD IF_FQM_ML_DETECT_BADI_INTF~TRAINING
     BY DATABASE PROCEDURE FOR HDB LANGUAGE SQLSCRIPT OPTIONS 
SUPPRESS SYNTAX ERRORS.
    lt_data = select CompanyCode, CertaintyLevel, Currency, 
PlanningLevel, CashPlanningGroup, GLAccount, BusinessPartner, 
Customer, Supplier, PartnerCompany, CostCenter, ProfitCenter,
    Segment, BusinessArea, Material, WBSElement, PaymentMethod, 
FinancialAccountType, FinancialTransactionType,  
BankAccountInternalID, LiquidityItem
    from :it_data;
   /* è°ƒç”¨ PAL éšæœºå†³ç­–æ ‘ç®—æ³• */
        CALL _sys_afl.pal_random_decision_trees(:lt_data, :it_
param, :et_model, :et_variable_importance, :et_error_rate, 
:et_confusion_matrix);
  ENDMETHOD.

---

Finally, the method shown in Listing 20.4 is encapsulated as a BAdI for extensibility. It implements the consumption logic in terms of applying requests to the trained model and providing inference results.

**ã€è¯‘æ–‡ã€‘** æœ€åï¼Œä»£ç æ¸…å• 20.4 ä¸­å±•ç¤ºçš„æ–¹æ³•ä¹Ÿè¢«å°è£…ä¸º BAdI ä»¥å®ç°å¯æ‰©å±•æ€§ã€‚å®ƒå®ç°äº†æ¶ˆè´¹é€»è¾‘ï¼Œå³å‘å·²è®­ç»ƒçš„æ¨¡å‹å‘é€è¯·æ±‚å¹¶æä¾›æ¨ç†ç»“æœã€‚

---

Listing 20.4 Coding for Model Inference
METHOD APPLY
    BY DATABASE PROCEDURE FOR HDB LANGUAGE SQLSCRIPT OPTIONS 
SUPPRESS SYNTAX ERRORS READ-ONLY
    USING CL_FQM_ML_DETECT_BADI=>PREDICT_WITH_MODEL_VERSION.
  CALL "CL_FQM_ML_DETECT_BADI=>PREDICT_WITH_MODEL_VERSION"(
    it_data   => :it_data,
    it_model  => :it_model,
    it_param  => :it_param,
    et_result => :et_result
  );
  ENDMETHOD.
METHOD IF_FQM_ML_DETECT_BADI_INTF~predict_with_model_version
     BY DATABASE PROCEDURE FOR HDB LANGUAGE SQLSCRIPT OPTIONS 
READ-ONLY.
    lt_data_uuid = select to_nchar(sysuuid) as id, OriginSystem, 
OriginApplication, OriginDocument, OriginTransaction, 
OriginTransactionQualifier, CashFlow,CompanyCode, CertaintyLevel, 
Currency, PlanningLevel, CashPlanningGroup, GLAccount, 
BusinessPartner, Customer, Supplier, PartnerCompany, CostCenter, 
ProfitCenter, 
Segment, BusinessArea, Material, WBSElement, PaymentMethod, 
FinancialAccountType, FinancialTransactionType,  
BankAccountInternalID
    FROM :it_data;
lt_data_predict = select id, 
CompanyCode, CertaintyLevel, Currency, PlanningLevel, 
CashPlanningGroup, GLAccount, BusinessPartner, Customer, 
Supplier, PartnerCompany, CostCenter, ProfitCenter,Segment, 
BusinessArea, Material, WBSElement, PaymentMethod, 
FinancialAccountType, FinancialTransactionType, 
BankAccountInternalID
    FROM :lt_data_uuid;
    /* Execute  prediction */
    CALL _sys_afl.pal_random_decision_trees_predict(:lt_data_
predict, :it_model, :it_param, lt_result);
    /* Prediction results are mapped to the composite keys */
    et_result = select OriginSystem, OriginApplication, 
OriginDocument, OriginTransaction, OriginTransactionQualifier, 
CashFlow, r.score as LiquidityItem, confidence FROM :lt_data_uuid 
as u INNER JOIN :lt_result as r ON u.id = r.id;
    ENDMETHOD.

**ã€è¯‘æ–‡ã€‘** ä»£ç æ¸…å• 20.4 æ¨¡å‹æ¨ç†ä»£ç 
METHOD APPLY
    BY DATABASE PROCEDURE FOR HDB LANGUAGE SQLSCRIPT OPTIONS 
SUPPRESS SYNTAX ERRORS READ-ONLY
    USING CL_FQM_ML_DETECT_BADI=>PREDICT_WITH_MODEL_VERSION.
  CALL "CL_FQM_ML_DETECT_BADI=>PREDICT_WITH_MODEL_VERSION"(
    it_data   => :it_data,
    it_model  => :it_model,
    it_param  => :it_param,
    et_result => :et_result
  );
  ENDMETHOD.
METHOD IF_FQM_ML_DETECT_BADI_INTF~predict_with_model_version
     BY DATABASE PROCEDURE FOR HDB LANGUAGE SQLSCRIPT OPTIONS 
READ-ONLY.
    lt_data_uuid = select to_nchar(sysuuid) as id, OriginSystem, 
OriginApplication, OriginDocument, OriginTransaction, 
OriginTransactionQualifier, CashFlow,CompanyCode, CertaintyLevel, 
Currency, PlanningLevel, CashPlanningGroup, GLAccount, 
BusinessPartner, Customer, Supplier, PartnerCompany, CostCenter, 
ProfitCenter, 
Segment, BusinessArea, Material, WBSElement, PaymentMethod, 
FinancialAccountType, FinancialTransactionType,  
BankAccountInternalID
    FROM :it_data;
lt_data_predict = select id, 
CompanyCode, CertaintyLevel, Currency, PlanningLevel, 
CashPlanningGroup, GLAccount, BusinessPartner, Customer, 
Supplier, PartnerCompany, CostCenter, ProfitCenter,Segment, 
BusinessArea, Material, WBSElement, PaymentMethod, 
FinancialAccountType, FinancialTransactionType, 
BankAccountInternalID
    FROM :lt_data_uuid;
    /* æ‰§è¡Œé¢„æµ‹ */
    CALL _sys_afl.pal_random_decision_trees_predict(:lt_data_
predict, :it_model, :it_param, lt_result);
    /* é¢„æµ‹ç»“æœæ˜ å°„åˆ°ç»„åˆé”® */
    et_result = select OriginSystem, OriginApplication, 
OriginDocument, OriginTransaction, OriginTransactionQualifier, 
CashFlow, r.score as LiquidityItem, confidence FROM :lt_data_uuid 
as u INNER JOIN :lt_result as r ON u.id = r.id;
    ENDMETHOD.

---

20.3 Implementing Side-by-Side AI Applications

**ã€è¯‘æ–‡ã€‘** 20.3 å®æ–½å¹¶è¡Œï¼ˆSide-by-Sideï¼‰AI åº”ç”¨

---

The method of using side-by-side artificial intelligence is used when the embedded artificial intelligence fails to fulfill the needs of the specific use case. This situation may arise if the suitable algorithm is not offered by SAP HANA, if external data is needed for training the model, or if the algorithm has substantial hardware demands (for instance, neural networks require a GPU and consume a significant amount of memory).

**ã€è¯‘æ–‡ã€‘** å½“åµŒå…¥å¼äººå·¥æ™ºèƒ½æ— æ³•æ»¡è¶³ç‰¹å®šç”¨ä¾‹çš„éœ€æ±‚æ—¶ï¼Œå°±ä¼šé‡‡ç”¨å¹¶è¡Œï¼ˆSide-by-Sideï¼‰äººå·¥æ™ºèƒ½çš„æ–¹æ³•ã€‚è¿™ç§æƒ…å†µå¯èƒ½å‡ºç°åœ¨ä»¥ä¸‹åœºæ™¯ï¼šSAP HANA æœªæä¾›åˆé€‚çš„ç®—æ³•ã€è®­ç»ƒæ¨¡å‹éœ€è¦å¤–éƒ¨æ•°æ®ï¼Œæˆ–è€…ç®—æ³•å¯¹ç¡¬ä»¶æœ‰æé«˜è¦æ±‚ï¼ˆä¾‹å¦‚ï¼Œç¥ç»ç½‘ç»œéœ€è¦ GPU ä¸”æ¶ˆè€—å¤§é‡å†…å­˜ï¼‰ã€‚

---

For the side-by-side application of artificial intelligence, it is necessary to develop an ABAP class, CDS view, and intelligent scenario on the SAP S/4HANA ABAP platform, while the training and inference pipelines are implemented in the SAP Business Technology Platform (SAP BTP). There are several development

**ã€è¯‘æ–‡ã€‘** å¯¹äºå¹¶è¡Œäººå·¥æ™ºèƒ½åº”ç”¨ï¼Œéœ€è¦åœ¨ SAP S/4HANA ABAP å¹³å°ä¸Šå¼€å‘ ABAP ç±»ã€CDS è§†å›¾å’Œæ™ºèƒ½åœºæ™¯ï¼Œè€Œåœ¨ SAP ä¸šåŠ¡æŠ€æœ¯äº‘å¹³å°ï¼ˆSAP BTPï¼‰ä¸Šå®æ–½è®­ç»ƒå’Œæ¨ç†ç®¡é“ã€‚åœ¨ SAP ä¸šåŠ¡æŠ€æœ¯äº‘å¹³å°ä¸Šå®æ–½äººå·¥æ™ºèƒ½ï¼Œæœ‰å¤šç§å¼€å‘ç¯å¢ƒå¯ä¾›é€‰æ‹©ã€‚

---

